import express from "express";
import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { z } from "zod";
import cors from "cors";
import crypto from "crypto";


function createServer() {
    const server = new McpServer({
        name: "Advanced Node Server",
        version: "2.0.0"
    }, {
        capabilities: {
            prompts: {},
            resources: {},
            tools: {}
        }
    });

    // 1. Basic Tool
    server.tool(
        "add",
        "Add two numbers",
        {
            a: z.number().describe("First number"),
            b: z.number().describe("Second number")
        },
        async ({ a, b }) => ({
            content: [{ type: "text", text: String(a + b) }]
        })
    );

    // 2. Complex Data Tool
    server.tool(
        "process_order",
        "Process a complex order object",
        {
            order: z.object({
                id: z.string(),
                items: z.array(z.object({
                    name: z.string(),
                    quantity: z.number(),
                    price: z.number()
                })),
                shipping: z.object({
                    address: z.string(),
                    expedited: z.boolean()
                })
            }).describe("The order details")
        },
        async ({ order }) => {
            const total = order.items.reduce((sum, item) => sum + (item.quantity * item.price), 0);
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        status: "processed",
                        order_id: order.id,
                        total_value: total,
                        expedited: order.shipping.expedited
                    }, null, 2)
                }]
            };
        }
    );

    // 3. Error Handling Tool
    server.tool(
        "generate_error",
        "Intentionally throws an error to test handling",
        {
            message: z.string().describe("Error message to throw")
        },
        async ({ message }) => {
            throw new Error(`Simulated Failure: ${message}`);
        }
    );

    // 4. Long Running Tool (Simulated)
    server.tool(
        "long_running_op",
        "Simulates a slow operation",
        {
            duration_ms: z.number().default(2000).describe("Duration in milliseconds")
        },
        async ({ duration_ms }) => {
            await new Promise(resolve => setTimeout(resolve, duration_ms));
            return {
                content: [{ type: "text", text: `Operation completed after ${duration_ms}ms` }]
            };
        }
    );

    // 5. Resource Support
    server.resource(
        "config",
        "config://app",
        async (uri) => ({
            contents: [{
                uri: uri.href,
                text: JSON.stringify({ environment: "test", debug: true, max_connections: 100 })
            }]
        })
    );

    // 6. Prompt Support
    server.prompt(
        "code_review",
        { code: z.string().describe("Code to review") },
        ({ code }) => ({
            messages: [{
                role: "user",
                content: { type: "text", text: `Please review this code:\n\n${code}\n\nKey areas to focus on: Security, Performance.` }
            }]
        })
    );

    return server;
}

const app = express();
app.use(cors());

// Logging middleware
app.use((req, res, next) => {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
    next();
});

app.get("/health", (req, res) => {
    res.send("OK");
});

// Map to store transports for each session
const transports = new Map();

app.get("/sse", async (req, res) => {
    console.log(`[DEBUG] PID: ${process.pid} Handling GET /sse`);
    console.log(`[DEBUG] User-Agent: ${req.headers['user-agent']}`);

    // Create the transport with the base endpoint path
    // The SDK will generate a session ID and append it to this path
    const transport = new SSEServerTransport("/message", res);

    // key bug fix: get the ID generated by the SDK
    const sessionId = transport.sessionId;

    console.log(`[DEBUG] Transport Generated Session ID: ${sessionId} for IP: ${req.socket.remoteAddress}`);

    transports.set(sessionId, transport);
    console.log(`[DEBUG] Transports Map Size: ${transports.size}`);
    console.log(`[DEBUG] Active Sessions: ${Array.from(transports.keys()).join(', ')}`);

    const server = createServer();

    // Clean up when connection closes
    res.on("close", () => {
        console.log(`[DEBUG] SSE connection close event fired for session ${sessionId}`);
        if (transports.has(sessionId)) {
            transports.delete(sessionId);
            console.log(`[DEBUG] Deleted session ${sessionId}. Map Size: ${transports.size}`);
        } else {
            console.log(`[DEBUG] Session ${sessionId} was already deleted or not found in map.`);
        }
    });

    try {
        await server.connect(transport);
        console.log(`[DEBUG] Server connected for session ${sessionId}`);
    } catch (err) {
        console.error(`[DEBUG] Error connecting server for session ${sessionId}:`, err);
    }
});

// Handler for message parsing
async function handleMessage(req, res) {
    const sessionId = req.query.sessionId;
    console.log(`Message received for session: ${sessionId}, URL: ${req.url}`);

    if (!sessionId) {
        // If no session ID, try to find the most recent one (fallback for single-user testing)
        // or just error out. 
        // For the MCP tester which might be misbehaving, let's try to grab the first active transport
        // if there is exactly one.
        if (transports.size === 1) {
            console.log("No sessionId provided, defaulting to single active transport");
            const transport = transports.values().next().value;
            await transport.handlePostMessage(req, res);
            return;
        }

        console.error("No sessionId provided and valid transport lookup failed");
        res.status(400).send("Session ID required");
        return;
    }

    const transport = transports.get(sessionId);
    if (transport) {
        await transport.handlePostMessage(req, res);
    } else {
        console.error(`No transport found for session ${sessionId}`);
        res.status(404).send("Session not found");
    }
}

app.post("/message", handleMessage);
// Fallback: Handle POST to /sse as well, in case the client ignores the endpoint event
app.post("/sse", handleMessage);
// Fallback: Handle POST to /mcp/sse/messages (another common convention)
app.post("/mcp/sse/messages", handleMessage);

app.listen(3000, () => {
    console.log("Advanced MCP Server running on port 3000");
});
